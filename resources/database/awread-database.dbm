<?xml version="1.0" encoding="UTF-8"?>
<!--
CAUTION: Do not modify this file unless you know what you are doing.
         Unexpected results may occur if the code is changed deliberately.
-->
<dbmodel pgmodeler-ver="0.9.3" use-changelog="false" last-position="0,603" last-zoom="0.95" max-obj-count="15"
	 default-owner="postgres">
<role name="anonymous">
</role>

<role name="writer">
</role>

<role name="reader">
</role>

<role name="postgraphile">
</role>

<database name="awread_database" is-template="false" allow-conns="true">
</database>

<schema name="public" layer="0" fill-color="#e1e1e1" sql-disabled="true">
</schema>

<extension name="pg_trgm">
</extension>

<schema name="private" layer="0" rect-visible="true" fill-color="#e1e1e1">
	<role name="postgres"/>
</schema>

<extension name="pgcrypto">
</extension>

<usertype name="jwt_token" configuration="composite">
	<schema name="public"/>
	<role name="postgres"/>
	<appended-sql><![CDATA[grant anonymous to reader;
grant anonymous to writer;
grant reader to writer;
grant anonymous to postgraphile;
grant reader to postgraphile;
grant writer to postgraphile;

grant connect on database awread_database  to anonymous, reader, writer, postgraphile;
grant usage on schema public to anonymous, reader, writer, postgraphile;
GRANT SELECT ON ALL TABLES IN SCHEMA public to anonymous, reader, writer, postgraphile;]]></appended-sql>
	<typeattrib name="userId">
		<type name="uuid" length="0"/>
	</typeattrib>
	<typeattrib name="role">
		<type name="text" length="0"/>
	</typeattrib>
	<typeattrib name="exp">
		<type name="numeric" length="0"/>
	</typeattrib>
</usertype>

<extension name="uuid-ossp">
	<schema name="public"/>
</extension>

<opclass  name="gin_trgm_ops" index-type="gin" default="false" sql-disabled="true">
	<schema name="public"/>
	<role name="postgres"/>
	<type name="smallint" length="0"/>
	<element type="storage">
		<type name="smallint" length="0"/>
	</element>
</opclass>

<table name="books" layer="0" collapse-mode="2" max-obj-count="14" z-value="0">
	<schema name="public"/>
	<role name="postgres"/>
	<appended-sql><![CDATA[-- create index title_gin_idx on public.books
-- using gin (title gin_trgm_ops);]]></appended-sql>
	<prepended-sql><![CDATA[set timezone='Asia/Ho_Chi_Minh';]]></prepended-sql>
	<position x="1220" y="720"/>
	<column name="bookId" not-null="true" default-value="uuid_generate_v4 ()">
		<type name="uuid" length="0"/>
	</column>
	<column name="userId" not-null="true">
		<type name="uuid" length="0"/>
	</column>
	<column name="categoryId" not-null="true">
		<type name="numeric" length="0"/>
	</column>
	<column name="publisherId" not-null="true">
		<type name="uuid" length="0"/>
	</column>
	<column name="title" not-null="true">
		<type name="text" length="0"/>
	</column>
	<column name="updatedAt" not-null="true" default-value="CURRENT_TIMESTAMP">
		<type name="timestamp with time zone" length="0" with-timezone="true"/>
	</column>
	<column name="completed" not-null="true" default-value="false">
		<type name="boolean" length="0"/>
	</column>
	<column name="published" not-null="true" default-value="false">
		<type name="boolean" length="0"/>
	</column>
	<column name="ages" not-null="true" default-value="2">
		<type name="numeric" length="0"/>
	</column>
	<column name="description">
		<type name="text" length="0"/>
	</column>
	<column name="cover">
		<type name="text" length="0"/>
	</column>
	<column name="createdAt">
		<type name="timestamp with time zone" length="0" with-timezone="true"/>
	</column>
	<constraint name="books_pk" type="pk-constr" table="public.books">
		<columns names="bookId" ref-type="src-columns"/>
	</constraint>
</table>

<table name="genres" layer="0" collapse-mode="2" max-obj-count="3" z-value="0">
	<schema name="public"/>
	<role name="postgres"/>
	<position x="1720" y="1300"/>
	<column name="genreId" not-null="true">
		<type name="numeric" length="0"/>
	</column>
	<column name="name">
		<type name="text" length="0"/>
	</column>
	<column name="description">
		<type name="text" length="0"/>
	</column>
	<constraint name="genres_pk" type="pk-constr" table="public.genres">
		<columns names="genreId" ref-type="src-columns"/>
	</constraint>
</table>

<table name="users" layer="0" collapse-mode="2" max-obj-count="19" z-value="0">
	<schema name="public"/>
	<role name="postgres"/>
	<position x="460" y="800"/>
	<column name="userId" not-null="true" default-value="uuid_generate_v4()">
		<type name="uuid" length="0"/>
	</column>
	<column name="username" not-null="true">
		<type name="text" length="0"/>
	</column>
	<column name="email">
		<type name="text" length="0"/>
	</column>
	<column name="name">
		<type name="text" length="0"/>
	</column>
	<column name="role" default-value="'reader'">
		<type name="text" length="0"/>
	</column>
	<column name="createdAt" default-value="now()">
		<type name="timestamp with time zone" length="0" with-timezone="true"/>
	</column>
	<column name="updatedAt" default-value="now()">
		<type name="timestamp with time zone" length="0" with-timezone="true"/>
	</column>
	<column name="phone">
		<type name="text" length="0"/>
	</column>
	<column name="code" default-value="+84">
		<type name="text" length="0"/>
	</column>
	<column name="age" default-value="2">
		<type name="numeric" length="0"/>
	</column>
	<column name="provider" default-value="'password'">
		<type name="text" length="0"/>
	</column>
	<column name="providerId">
		<type name="text" length="0"/>
	</column>
	<column name="firstname">
		<type name="text" length="0"/>
	</column>
	<column name="middlename">
		<type name="text" length="0"/>
	</column>
	<column name="lastname">
		<type name="text" length="0"/>
	</column>
	<column name="avatar">
		<type name="text" length="0"/>
	</column>
	<constraint name="users_pk" type="pk-constr" table="public.users">
		<columns names="userId" ref-type="src-columns"/>
	</constraint>
</table>

<table name="users" layer="0" collapse-mode="2" max-obj-count="2" z-value="0">
	<schema name="private"/>
	<role name="postgres"/>
	<position x="80" y="820"/>
	<column name="userId" not-null="true">
		<type name="uuid" length="0"/>
	</column>
	<column name="passwordHash">
		<type name="text" length="0"/>
	</column>
	<constraint name="user_pk" type="pk-constr" table="private.users">
		<columns names="userId" ref-type="src-columns"/>
	</constraint>
</table>

<table name="chapters" layer="0" collapse-mode="2" max-obj-count="8" z-value="0">
	<schema name="public"/>
	<role name="postgres"/>
	<position x="1760" y="660"/>
	<column name="chapterId" not-null="true" default-value="uuid_generate_v4 ()">
		<type name="uuid" length="0"/>
	</column>
	<column name="published" default-value="true">
		<type name="boolean" length="0"/>
	</column>
	<column name="position" default-value="0">
		<type name="numeric" length="0"/>
	</column>
	<column name="bookId" not-null="true">
		<type name="uuid" length="0"/>
	</column>
	<column name="title">
		<type name="text" length="0"/>
	</column>
	<column name="createdAt" not-null="true" default-value="now()">
		<type name="timestamp" length="0"/>
	</column>
	<column name="updatedAt" not-null="true" default-value="now()">
		<type name="timestamp" length="0"/>
	</column>
	<constraint name="chapters_pk" type="pk-constr" table="public.chapters">
		<columns names="chapterId" ref-type="src-columns"/>
	</constraint>
</table>

<table name="categories" layer="0" collapse-mode="2" max-obj-count="2" z-value="0">
	<schema name="public"/>
	<role name="postgres"/>
	<position x="1480" y="1340"/>
	<column name="categoryId" not-null="true">
		<type name="numeric" length="0"/>
	</column>
	<column name="name">
		<type name="text" length="0"/>
	</column>
	<constraint name="categories_pk" type="pk-constr" table="public.categories">
		<columns names="categoryId" ref-type="src-columns"/>
	</constraint>
</table>

<table name="books_genres" layer="0" collapse-mode="2" max-obj-count="3" z-value="0">
	<schema name="public"/>
	<role name="postgres"/>
	<position x="1640" y="1040"/>
	<column name="bookId" not-null="true">
		<type name="uuid" length="0"/>
	</column>
	<column name="genreId" not-null="true">
		<type name="numeric" length="0"/>
	</column>
	<constraint name="books_genres_pk" type="pk-constr" table="public.books_genres">
		<columns names="bookId,genreId" ref-type="src-columns"/>
	</constraint>
</table>

<table name="book_visits" layer="0" collapse-mode="2" max-obj-count="8" z-value="0">
	<schema name="public"/>
	<role name="postgres"/>
	<position x="480" y="460"/>
	<column name="ip" not-null="true">
		<type name="text" length="0"/>
	</column>
	<column name="userId" not-null="true">
		<type name="uuid" length="0"/>
	</column>
	<column name="bookId" not-null="true">
		<type name="uuid" length="0"/>
	</column>
	<column name="chapterId" not-null="true">
		<type name="uuid" length="0"/>
	</column>
	<column name="visitTime" not-null="true" default-value="now()">
		<type name="timestamp" length="0"/>
	</column>
	<column name="count" not-null="true" default-value="0">
		<type name="numeric" length="0"/>
	</column>
	<column name="isMobile" not-null="true" default-value="false">
		<type name="boolean" length="0"/>
	</column>
	<constraint name="book_visits_pk" type="pk-constr" table="public.book_visits">
		<columns names="ip,userId,bookId,chapterId,visitTime" ref-type="src-columns"/>
	</constraint>
</table>

<table name="authors" layer="0" collapse-mode="2" max-obj-count="3" z-value="0">
	<schema name="public"/>
	<role name="postgres"/>
	<position x="800" y="780"/>
	<column name="bookId" not-null="true">
		<type name="uuid" length="0"/>
	</column>
	<column name="userId" not-null="true">
		<type name="uuid" length="0"/>
	</column>
	<constraint name="books_by_users_pk" type="pk-constr" table="public.authors">
		<columns names="bookId,userId" ref-type="src-columns"/>
	</constraint>
</table>

<table name="books_rank" layer="0" collapse-mode="2" max-obj-count="8" z-value="0">
	<schema name="public"/>
	<role name="postgres"/>
	<position x="1400" y="1520"/>
	<column name="book_id" not-null="true" default-value="uuid_generate_v4 ()">
		<type name="uuid" length="0"/>
	</column>
	<column name="title" not-null="true">
		<type name="text" length="0"/>
	</column>
	<column name="genreIds">
		<type name="uuid" length="0" dimension="1"/>
	</column>
	<column name="categoryId">
		<type name="uuid" length="0"/>
	</column>
	<column name="sold" default-value="0">
		<type name="numeric" length="0"/>
	</column>
	<column name="rate">
		<type name="numeric" length="4" precision="2"/>
	</column>
	<column name="view" default-value="0">
		<type name="numeric" length="0"/>
	</column>
</table>

<table name="publishers" layer="0" collapse-mode="2" max-obj-count="2" z-value="0">
	<schema name="public"/>
	<role name="postgres"/>
	<position x="2040" y="900"/>
	<column name="publisherId" not-null="true" default-value="uuid_generate_v4 ()">
		<type name="uuid" length="0"/>
	</column>
	<column name="name" not-null="true">
		<type name="text" length="0"/>
	</column>
	<constraint name="publisher_pk" type="pk-constr" table="public.publishers">
		<columns names="publisherId" ref-type="src-columns"/>
	</constraint>
</table>

<function name="set_updateAt"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="plpgsql"/>
	<return-type>
	<type name="trigger" length="0"/>
	</return-type>
	<definition><![CDATA[begin
	new."updatedAt" := current_timestamp;
	return new;
end;]]></definition>
</function>

<index name="chapters_bookId_idx" table="public.chapters"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="0">
		<idxelement use-sorting="false">
			<column name="&quot;bookId&quot;"/>
		</idxelement>
</index>

<table name="contents" layer="0" collapse-mode="2" max-obj-count="2" z-value="0">
	<schema name="public"/>
	<role name="postgres"/>
	<position x="1740" y="480"/>
	<column name="chapterId" not-null="true">
		<type name="uuid" length="0"/>
	</column>
	<column name="content">
		<type name="text" length="0"/>
	</column>
	<constraint name="contents_pk" type="pk-constr" table="public.contents">
		<columns names="chapterId" ref-type="src-columns"/>
	</constraint>
</table>

<function name="start_new_chapter"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="plpgsql"/>
	<return-type>
	<type name="uuid" length="0"/>
	</return-type>
	<parameter name="chapter">
		<type name="jsonb" length="0"/>
	</parameter>
	<definition><![CDATA[/*
declare 
"newChapterId" numeric;
begin

insert into categories("categoryId", name)
values(
(chapter ->> 'categoryId')::numeric,
(chapter ->> 'title')::text
) returning "categoryId" into "newChapterId";
*/


declare 
"newChapterId" uuid;
begin

insert into chapters(published, position, "bookId", title)
values(
(chapter ->> 'published')::boolean,
(chapter ->> 'position')::numeric,
(chapter ->> 'bookId')::uuid,
(chapter ->> 'title')::text
) 
returning "chapterId"
into "newChapterId";



insert into contents("chapterId", content)
values("newChapterId", (chapter ->> 'content')::text);

return "newChapterId";
end;]]></definition>
</function>

<function name="hello_world"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="plpgsql"/>
	<return-type>
	<type name="text" length="0"/>
	</return-type>
	<definition><![CDATA[begin
return 'hello world';
end;]]></definition>
</function>

<function name="search_books"
		window-func="false"
		returns-setof="true"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="50">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="plpgsql"/>
	<return-type>
	<type name="public.books" length="0"/>
	</return-type>
	<parameter name="searchTerm">
		<type name="text" length="0"/>
	</parameter>
	<parameter name="searchUserId">
		<type name="uuid" length="0"/>
	</parameter>
	<definition><![CDATA[begin 
   RETURN QUERY SELECT
		*
    FROM
        books
    WHERE "searchTerm" % ANY(STRING_TO_ARRAY(title,' ')) 
	AND  ("searchUserId" is null or "searchUserId" = public.books."userId")
    order by SIMILARITY("searchTerm",title) desc;
end;]]></definition>
</function>

<index name="books_title_gin_idx" table="public.books"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="gin" factor="0" sql-disabled="true">
		<idxelement use-sorting="false">
			<column name="title"/>
			<opclass  signature="public.gin_trgm_ops USING gin"/>
		</idxelement>
</index>

<trigger name="book_updated_at" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="false" del-event="false" upd-event="true" trunc-event="false"
	 table="public.books">
		<function signature="public.&quot;set_updateAt&quot;()"/>
</trigger>

<trigger name="person_updated_at" firing-type="BEFORE" per-line="false" constraint="false"
	 ins-event="false" del-event="false" upd-event="true" trunc-event="false"
	 table="public.users">
		<function signature="public.&quot;set_updateAt&quot;()"/>
</trigger>

<function name="register_user"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY DEFINER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="plpgsql"/>
	<return-type>
	<parameter name="case">
		<type name="text" length="0"/>
	</parameter>
	<parameter name="user">
		<type name="public.users" length="0"/>
	</parameter>
	</return-type>
	<parameter name="username">
		<type name="text" length="0"/>
	</parameter>
	<parameter name="password">
		<type name="text" length="0"/>
	</parameter>
	<parameter name="email">
		<type name="text" length="0"/>
	</parameter>
	<parameter name="phone">
		<type name="text" length="0"/>
	</parameter>
	<parameter name="provider">
		<type name="text" length="0"/>
	</parameter>
	<parameter name="providerId">
		<type name="text" length="0"/>
	</parameter>
	<definition><![CDATA[declare 
	"userAccount" public.users;
	"inputUsername" text := username;
	"inputEmail" text := email;
	"inputPhone" text := phone;
begin

	select * into "userAccount"
	from public.users as u
	where 
	(u.username = "inputUsername" and length("inputUsername") > 0) or
	(u.email = "inputEmail" and length("inputEmail") > 0 ) or
	(u.phone = "inputPhone" and length("inputPhone") > 0);

	if "userAccount" IS NULL then 

		insert into public.users(
			username,
			email,
			phone,
			provider,
			"providerId"
		) values (
			username, 
			email,
			phone, 
			provider,
			"providerId"
		)
		returning * into "userAccount";	

		insert into private.users("userId", "passwordHash") values(
			"userAccount"."userId",
			crypt(password, gen_salt('bf'))
	    );

		return query select 'success', "userAccount";
		
	else
		return query select 'duplicated', "userAccount";
	end if;
end;]]></definition>
</function>

<function name="authenticate_user"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY DEFINER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="plpgsql"/>
	<return-type>
	<parameter name="accessToken">
		<type name="public.jwt_token" length="0"/>
	</parameter>
	<parameter name="user">
		<type name="public.users" length="0"/>
	</parameter>
	<parameter name="matchPassword">
		<type name="boolean" length="0"/>
	</parameter>
	</return-type>
	<parameter name="loginname">
		<type name="text" length="0"/>
	</parameter>
	<parameter name="password">
		<type name="text" length="0"/>
	</parameter>
	<definition><![CDATA[declare 
	"accessToken" public.jwt_token;
	account public.users;
	"matchPassword" boolean := false;
	"accountPasswordHash" text;
begin
  select * into account
  from public.users
  where
	public.users.email = loginname or 
	public.users.phone = loginname or 
	public.users.username = loginname;

	select "passwordHash" into "accountPasswordHash"
	from private.users
	where account."userId" = "userId";

	"matchPassword"  := "accountPasswordHash" = crypt(password, "accountPasswordHash" );

  	if "matchPassword" then
		"accessToken" := (account."userId", account.role, extract(epoch from (now() + interval '3 months')))::public.jwt_token;
    	return query select "accessToken", account, "matchPassword";
  	elsif account is not null then 
		return query select "accessToken", account, "matchPassword";
	else 
    	return query select "accessToken", account, "matchPassword";
  	end if;
end;]]></definition>
</function>

<view name="v_random_books" layer="0" collapse-mode="2" max-obj-count="3" z-value="0">
	<schema name="public"/>
	<role name="postgres"/>
	<position x="1100" y="1480"/>
	<reference>
		<expression><![CDATA["bookId",
title,
cover,
"userId",
ARRAY_AGG(public.books_genres."genreId") as "genreIds"]]></expression>
	</reference>
	<reference>
		<expression><![CDATA[public.books natural join public.books_genres
]]></expression>
	</reference>
	<reference>
		<expression><![CDATA[group by 1,2
order by random();]]></expression>
	</reference>
	<expression type="select-exp">0</expression>
	<expression type="from-exp">1</expression>
	<expression type="end-exp">2</expression>
</view>

<view name="mv_books_latest_chapters" layer="0" materialized="true" collapse-mode="2" max-obj-count="3" z-value="0">
	<schema name="public"/>
	<role name="postgres"/>
	<position x="900" y="1560"/>
	<reference>
		<expression><![CDATA[   public.chapters."bookId",
   public.books.title,
   public.books."updatedAt",
   public.books."categoryId",
   jsonb_agg(distinct "newestChapters") as "newestChapters"]]></expression>
	</reference>
	<reference>
		<expression><![CDATA[public.chapters
   join lateral (
	select jsonb_build_object(
		'chapterId', c."chapterId",
		'position', c.position
    ) as "newestChapters"
	from chapters c
	where c."bookId" = chapters."bookId"
	group by c."bookId", c.position, c."chapterId"
	order by c.position desc
	limit 2
) chapters_results on true   inner join books on books."bookId" = chapters."bookId"   group by chapters."bookId", books.title, public.books."updatedAt", public.books."categoryId"]]></expression>
	</reference>
	<reference>
		<expression><![CDATA[order by chapters."bookId";]]></expression>
	</reference>
	<expression type="select-exp">0</expression>
	<expression type="from-exp">1</expression>
	<expression type="end-exp">2</expression>
</view>

<view name="mv_most_view_books" layer="0" materialized="true" collapse-mode="2" max-obj-count="3" z-value="0">
	<schema name="public"/>
	<role name="postgres"/>
	<position x="640" y="1560"/>
	<reference>
		<expression><![CDATA[   public.book_visits."bookId",
   public.books.title,
   public.books."categoryId",
   public.books."updatedAt",
   public.mv_books_latest_chapters."newestChapters",
   sum(public.book_visits.count) as "views"]]></expression>
	</reference>
	<reference>
		<expression><![CDATA[public.book_visits natural join public.books natural join public.mv_books_latest_chapters]]></expression>
	</reference>
	<reference>
		<expression><![CDATA[   group by 1,2,3,4,5
order by 6 DESC;
]]></expression>
	</reference>
	<expression type="select-exp">0</expression>
	<expression type="from-exp">1</expression>
	<expression type="end-exp">2</expression>
</view>

<view name="mv_detail_books" layer="0" materialized="true" collapse-mode="2" max-obj-count="3" z-value="0">
	<schema name="public"/>
	<role name="postgres"/>
	<position x="1180" y="1560"/>
	<reference>
		<expression><![CDATA[public.books.*,
   (select 
		jsonb_agg(jsonb_build_object(
			'id', genres."genreId",
			'name', genres."name"
		))
	 from 
	 	books_genres
	 join 
	 	genres
	 on 
	 	books_genres."genreId" = genres."genreId"
	 where 
	 	books_genres."bookId" = books."bookId"
	) as genres,
   (select 
		jsonb_agg(jsonb_build_object(
			'id', users."userId",
			'name', users."name"
		))
	 from 
	 	authors
	 join 
	 	users
	 on 
	 	authors."userId" = users."userId"
	 where 
	 	authors."bookId" = books."bookId"
	) as authors]]></expression>
	</reference>
	<reference>
		<expression><![CDATA[public.books]]></expression>
	</reference>
	<reference>
		<expression><![CDATA[   group by books."bookId"]]></expression>
	</reference>
	<expression type="select-exp">0</expression>
	<expression type="from-exp">1</expression>
	<expression type="end-exp">2</expression>
</view>

<function name="current_user"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="plpgsql"/>
	<return-type>
	<type name="public.users" length="0"/>
	</return-type>
	<definition><![CDATA[declare 
	"currentUser" public.users;
begin
	select * into "currentUser"
	from public.users
	where  "userId" = nullif(current_setting('jwt.claims.userId', true), '')::uuid;
	return "currentUser";
end;

]]></definition>
</function>

<function name="authenticate_social_user"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY DEFINER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<appended-sql><![CDATA[grant anonymous to reader;
grant anonymous to writer;
grant reader to writer;
grant anonymous to postgraphile;
grant reader to postgraphile;
grant writer to postgraphile;]]></appended-sql>
	<language name="plpgsql"/>
	<return-type>
	<parameter name="accessToken">
		<type name="public.jwt_token" length="0"/>
	</parameter>
	<parameter name="user">
		<type name="public.users" length="0"/>
	</parameter>
	</return-type>
	<parameter name="provider">
		<type name="text" length="0"/>
	</parameter>
	<parameter name="providerId">
		<type name="text" length="0"/>
	</parameter>
	<definition><![CDATA[declare 
	"accessToken" public.jwt_token;
	account public.users;
	"userProvider" text := provider;
	"userProviderId" text := "providerId";
begin
  select * into account
  from public.users
  where
	public.users.provider = "userProvider" and
	public.users."providerId" = "userProviderId";

  if account is null  then
	return query select "accessToken", account;
   
  else
   return query select (account."userId", account.role, extract(epoch from (now() + interval '3 months')))::public.jwt_token, account; 
  end if;
end;]]></definition>
</function>

<function name="get_author_books"
		window-func="false"
		returns-setof="true"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="1000">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="plpgsql"/>
	<return-type>
	<type name="public.mv_books_latest_chapters" length="0"/>
	</return-type>
	<parameter name="userId">
		<type name="uuid" length="0"/>
	</parameter>
	<definition><![CDATA[
declare 
	"authorId" uuid := "userId";
begin
	return query select
	   b."bookId",
	   b.title,
	   b."updatedAt",
	   b."categoryId",
	   b."newestChapters"
	from
	   public.mv_books_latest_chapters as b
	   natural join public.authors as a
	where 
		a."userId" = "authorId"
	order by
		b."updatedAt" desc;
end;]]></definition>
</function>

<constraint name="books_userId_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="NO ACTION" del-action="CASCADE" ref-table="public.users" table="public.books">
	<columns names="userId" ref-type="src-columns"/>
	<columns names="userId" ref-type="dst-columns"/>
</constraint>

<constraint name="books_category_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="NO ACTION" del-action="CASCADE" ref-table="public.categories" table="public.books">
	<columns names="categoryId" ref-type="src-columns"/>
	<columns names="categoryId" ref-type="dst-columns"/>
</constraint>

<constraint name="books_publisherId_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="NO ACTION" del-action="CASCADE" ref-table="public.publishers" table="public.books">
	<columns names="publisherId" ref-type="src-columns"/>
	<columns names="publisherId" ref-type="dst-columns"/>
</constraint>

<constraint name="public_users_userId_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="NO ACTION" del-action="CASCADE" ref-table="public.users" table="private.users">
	<columns names="userId" ref-type="src-columns"/>
	<columns names="userId" ref-type="dst-columns"/>
</constraint>

<constraint name="chapters_bookId_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="NO ACTION" del-action="CASCADE" ref-table="public.books" table="public.chapters">
	<columns names="bookId" ref-type="src-columns"/>
	<columns names="bookId" ref-type="dst-columns"/>
</constraint>

<constraint name="books_genres_bookId_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="NO ACTION" del-action="CASCADE" ref-table="public.books" table="public.books_genres">
	<columns names="bookId" ref-type="src-columns"/>
	<columns names="bookId" ref-type="dst-columns"/>
</constraint>

<constraint name="books_genres_genreId_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="NO ACTION" del-action="CASCADE" ref-table="public.genres" table="public.books_genres">
	<columns names="genreId" ref-type="src-columns"/>
	<columns names="genreId" ref-type="dst-columns"/>
</constraint>

<constraint name="book_visits_bookId_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="NO ACTION" del-action="CASCADE" ref-table="public.books" table="public.book_visits">
	<columns names="bookId" ref-type="src-columns"/>
	<columns names="bookId" ref-type="dst-columns"/>
</constraint>

<constraint name="book_visits_chapterId_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="NO ACTION" del-action="CASCADE" ref-table="public.chapters" table="public.book_visits">
	<columns names="chapterId" ref-type="src-columns"/>
	<columns names="chapterId" ref-type="dst-columns"/>
</constraint>

<constraint name="books_visits_userId_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="NO ACTION" del-action="CASCADE" ref-table="public.users" table="public.book_visits">
	<columns names="userId" ref-type="src-columns"/>
	<columns names="userId" ref-type="dst-columns"/>
</constraint>

<constraint name="books_by_users_bookId_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="NO ACTION" del-action="CASCADE" ref-table="public.books" table="public.authors">
	<columns names="bookId" ref-type="src-columns"/>
	<columns names="bookId" ref-type="dst-columns"/>
</constraint>

<constraint name="books_by_users_userId_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="NO ACTION" del-action="CASCADE" ref-table="public.users" table="public.authors">
	<columns names="userId" ref-type="src-columns"/>
	<columns names="userId" ref-type="dst-columns"/>
</constraint>

<constraint name="contents_chapterId_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="public.chapters" table="public.contents">
	<columns names="chapterId" ref-type="src-columns"/>
	<columns names="chapterId" ref-type="dst-columns"/>
</constraint>

<relationship name="rel_books_users" type="relfk" layer="0"
	 src-table="public.books"
	 dst-table="public.users" reference-fk="books_userId_fk"
	 src-required="false" dst-required="true"/>

<relationship name="rel_books_categories" type="relfk" layer="0"
	 src-table="public.books"
	 dst-table="public.categories" reference-fk="books_category_fk"
	 src-required="false" dst-required="true"/>

<relationship name="rel_books_publishers" type="relfk" layer="0"
	 src-table="public.books"
	 dst-table="public.publishers" reference-fk="books_publisherId_fk"
	 src-required="false" dst-required="true"/>

<relationship name="rel_chapters_books" type="relfk" layer="0"
	 src-table="public.chapters"
	 dst-table="public.books" reference-fk="chapters_bookId_fk"
	 src-required="false" dst-required="true"/>

<relationship name="rel_books_genres_books" type="relfk" layer="0"
	 src-table="public.books_genres"
	 dst-table="public.books" reference-fk="books_genres_bookId_fk"
	 src-required="false" dst-required="true"/>

<relationship name="rel_books_genres_genres" type="relfk" layer="0"
	 src-table="public.books_genres"
	 dst-table="public.genres" reference-fk="books_genres_genreId_fk"
	 src-required="false" dst-required="true"/>

<relationship name="rel_book_visits_books" type="relfk" layer="0"
	 src-table="public.book_visits"
	 dst-table="public.books" reference-fk="book_visits_bookId_fk"
	 src-required="false" dst-required="true"/>

<relationship name="rel_book_visits_chapters" type="relfk" layer="0"
	 src-table="public.book_visits"
	 dst-table="public.chapters" reference-fk="book_visits_chapterId_fk"
	 src-required="false" dst-required="true"/>

<relationship name="rel_book_visits_users" type="relfk" layer="0"
	 src-table="public.book_visits"
	 dst-table="public.users" reference-fk="books_visits_userId_fk"
	 src-required="false" dst-required="true"/>

<relationship name="rel_authors_books" type="relfk" layer="0"
	 src-table="public.authors"
	 dst-table="public.books" reference-fk="books_by_users_bookId_fk"
	 src-required="false" dst-required="true"/>

<relationship name="rel_authors_users" type="relfk" layer="0"
	 src-table="public.authors"
	 dst-table="public.users" reference-fk="books_by_users_userId_fk"
	 src-required="false" dst-required="true"/>

<relationship name="rel_contents_chapters" type="relfk" layer="0"
	 src-table="public.contents"
	 dst-table="public.chapters" reference-fk="contents_chapterId_fk"
	 src-required="false" dst-required="true"/>

<relationship name="rel_user_users" type="relfk" layer="0"
	 src-table="private.users"
	 dst-table="public.users" reference-fk="public_users_userId_fk"
	 src-required="false" dst-required="true"/>

<permission>
	<object name="awread_database" type="database"/>
	<roles names="reader"/>
	<privileges create="grant-op"/>
</permission>
</dbmodel>
